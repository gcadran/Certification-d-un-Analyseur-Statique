// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion {
  implicit def int2int(i: utilities.Datatype.Int.int): Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i) => Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
     else {
       val (r, s): (BigInt, BigInt) =
         (
             (k: BigInt) =>
               (l: BigInt) =>
                 if (l == 0) (BigInt(0), k)
                 else
                   (k.abs /% l.abs)
         ).apply(k).apply(BigInt(2));
       ((if (BigInt(0) < k) r else (-r) - s), s == BigInt(1))
     })

  def char_of_integer(k: BigInt): Str.char = {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    Str.Chara(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil)     => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[Str.char] = {
    (l.map(c => {
      val k: Int = c.toInt;
      if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal")
    }))
      .map(a => char_of_integer(a))
  }

  def explode(s: String): List[Str.char] = {
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s: String): List[Str.char] = explode(s)

  // conversion from Scala List[Char] to HOL List[Str.char]
  implicit def charList2charList(l: List[Char]): List[Str.char] =
    explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[Str.char] on first position
  implicit def tupleString2tupleString[T](
      t: (List[Char], T)
  ): (List[Str.char], T) = t match {
    case (e1, e2) => (charList2charList(e1), e2)
  }

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2dataint(i: Int.int): utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i) => utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: Str.char): Char = {
    x match {
      case Str.Chara(x1, x2, x3, x4, x5, x6, x7, x8) => {
        var n = 0;
        n = if (x8) 2 * n + 1 else 2 * n;
        n = if (x7) 2 * n + 1 else 2 * n;
        n = if (x6) 2 * n + 1 else 2 * n;
        n = if (x5) 2 * n + 1 else 2 * n;
        n = if (x4) 2 * n + 1 else 2 * n;
        n = if (x3) 2 * n + 1 else 2 * n;
        n = if (x2) 2 * n + 1 else 2 * n;
        n = if (x1) 2 * n + 1 else 2 * n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[Str.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
object equal {
  implicit def `Product_Type.equal_prod`[A : equal, B : equal]: equal[(A, B)] =
    new equal[(A, B)] {
    val `HOL.equal` = (a: (A, B), b: (A, B)) =>
      Product_Type.equal_proda[A, B](a, b)
  }
  implicit def `tp67.equal_absint`: equal[tp67.absint] = new equal[tp67.absint]
    {
    val `HOL.equal` = (a: tp67.absint, b: tp67.absint) =>
      tp67.equal_absinta(a, b)
  }
  implicit def `Str.equal_char`: equal[Str.char] = new equal[Str.char] {
    val `HOL.equal` = (a: Str.char, b: Str.char) => Str.equal_chara(a, b)
  }
  implicit def `Lista.equal_list`[A : equal]: equal[List[A]] = new
    equal[List[A]] {
    val `HOL.equal` = (a: List[A], b: List[A]) => Lista.equal_lista[A](a, b)
  }
}

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object Code_Numeral {

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def one_int: int = int_of_integer(BigInt(1))

def less_int(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) < Code_Numeral.integer_of_int(l)

def plus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) +
                   Code_Numeral.integer_of_int(l))

def zero_int: int = int_of_integer(BigInt(0))

def equal_int(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

def minus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) -
                   Code_Numeral.integer_of_int(l))

def uminus_int(k: int): int =
  int_of_integer((- (Code_Numeral.integer_of_int(k))))

} /* object Int */

object Product_Type {

def equal_proda[A : HOL.equal, B : HOL.equal](x0: (A, B), x1: (A, B)): Boolean =
  (x0, x1) match {
  case ((x1, x2), (y1, y2)) => HOL.eq[A](x1, y1) && HOL.eq[B](x2, y2)
}

def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
  case (p, true) => p
  case (p, false) => ! p
  case (true, p) => p
  case (false, p) => ! p
}

} /* object Product_Type */

object Str {

abstract sealed class char
final case class Chara(a: Boolean, b: Boolean, c: Boolean, d: Boolean,
                        e: Boolean, f: Boolean, g: Boolean, h: Boolean)
  extends char

def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
  case (Chara(x1, x2, x3, x4, x5, x6, x7, x8),
         Chara(y1, y2, y3, y4, y5, y6, y7, y8))
    => Product_Type.equal_bool(x1, y1) &&
         (Product_Type.equal_bool(x2, y2) &&
           (Product_Type.equal_bool(x3, y3) &&
             (Product_Type.equal_bool(x4, y4) &&
               (Product_Type.equal_bool(x5, y5) &&
                 (Product_Type.equal_bool(x6, y6) &&
                   (Product_Type.equal_bool(x7, y7) &&
                     Product_Type.equal_bool(x8, y8)))))))
}

} /* object Str */

object Lista {

def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
  case (Nil, Nil) => true
}

def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
  case (f, Nil) => Nil
  case (f, x21 :: x22) => f(x21) :: map[A, B](f, x22)
}

} /* object Lista */

object tp67 {

abstract sealed class absint
final case class Neg() extends absint
final case class Zero() extends absint
final case class Pos() extends absint
final case class Nonnull() extends absint
final case class Any() extends absint
final case class Undef() extends absint

def equal_absinta(x0: absint, x1: absint): Boolean = (x0, x1) match {
  case (Any(), Undef()) => false
  case (Undef(), Any()) => false
  case (Nonnull(), Undef()) => false
  case (Undef(), Nonnull()) => false
  case (Nonnull(), Any()) => false
  case (Any(), Nonnull()) => false
  case (Pos(), Undef()) => false
  case (Undef(), Pos()) => false
  case (Pos(), Any()) => false
  case (Any(), Pos()) => false
  case (Pos(), Nonnull()) => false
  case (Nonnull(), Pos()) => false
  case (Zero(), Undef()) => false
  case (Undef(), Zero()) => false
  case (Zero(), Any()) => false
  case (Any(), Zero()) => false
  case (Zero(), Nonnull()) => false
  case (Nonnull(), Zero()) => false
  case (Zero(), Pos()) => false
  case (Pos(), Zero()) => false
  case (Neg(), Undef()) => false
  case (Undef(), Neg()) => false
  case (Neg(), Any()) => false
  case (Any(), Neg()) => false
  case (Neg(), Nonnull()) => false
  case (Nonnull(), Neg()) => false
  case (Neg(), Pos()) => false
  case (Pos(), Neg()) => false
  case (Neg(), Zero()) => false
  case (Zero(), Neg()) => false
  case (Undef(), Undef()) => true
  case (Any(), Any()) => true
  case (Nonnull(), Nonnull()) => true
  case (Pos(), Pos()) => true
  case (Zero(), Zero()) => true
  case (Neg(), Neg()) => true
}

abstract sealed class option[A]
final case class None[A]() extends option[A]
final case class Some[A](a: A) extends option[A]

def equal_option[A : HOL.equal](x0: option[A], x1: option[A]): Boolean =
  (x0, x1) match {
  case (None(), Some(x2)) => false
  case (Some(x2), None()) => false
  case (Some(x2), Some(y2)) => HOL.eq[A](x2, y2)
  case (None(), None()) => true
}

def update(xa0: List[(List[Str.char], absint)], x: List[Str.char], a: absint):
      List[(List[Str.char], absint)]
  =
  (xa0, x, a) match {
  case (Nil, x, a) => List((x, a))
  case ((y, b) :: t, x, a) =>
    (if (Lista.equal_lista[Str.char](x, y)) (x, a) :: t
      else (y, b) :: update(t, x, a))
}

def refine_false6(x0: condition, tab: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  (x0, tab) match {
  case (Eq(Variable(x), Constant(n)), tab) =>
    (if (Int.equal_int(n, Int.zero_int)) update(tab, x, Nonnull()) else tab)
  case (Eq(Constant(n), Variable(x)), tab) =>
    (if (Int.equal_int(n, Int.zero_int)) update(tab, x, Nonnull()) else tab)
  case (Eq(Constant(vb), Constant(v)), tab) => tab
  case (Eq(Constant(vb), Sum(v, vc)), tab) => tab
  case (Eq(Constant(vb), Sub(v, vc)), tab) => tab
  case (Eq(Sum(vb, vc), va), tab) => tab
  case (Eq(Sub(vb, vc), va), tab) => tab
  case (Eq(Variable(va), Variable(vb)), tab) => tab
  case (Eq(v, Sum(vb, vc)), tab) => tab
  case (Eq(v, Sub(vb, vc)), tab) => tab
}

def safeexecabs6(x0: absint): Boolean = x0 match {
  case Zero() => false
  case Any() => false
  case Undef() => false
  case Pos() => true
  case Neg() => true
  case Nonnull() => true
}

def refine_true6(x0: condition, tab: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  (x0, tab) match {
  case (Eq(Variable(x), Constant(n)), tab) =>
    (if (Int.equal_int(n, Int.zero_int)) update(tab, x, Zero()) else tab)
  case (Eq(Constant(n), Variable(x)), tab) =>
    (if (Int.equal_int(n, Int.zero_int)) update(tab, x, Zero()) else tab)
  case (Eq(Constant(vb), Constant(v)), tab) => tab
  case (Eq(Constant(vb), Sum(v, vc)), tab) => tab
  case (Eq(Constant(vb), Sub(v, vc)), tab) => tab
  case (Eq(Sum(vb, vc), va), tab) => tab
  case (Eq(Sub(vb, vc), va), tab) => tab
  case (Eq(Variable(va), Variable(vb)), tab) => tab
  case (Eq(v, Sum(vb, vc)), tab) => tab
  case (Eq(v, Sub(vb, vc)), tab) => tab
}

def minusabs6(x0: absint, uu: absint): absint = (x0, uu) match {
  case (Undef(), uu) => Any()
  case (Neg(), Undef()) => Any()
  case (Zero(), Undef()) => Any()
  case (Pos(), Undef()) => Any()
  case (Nonnull(), Undef()) => Any()
  case (Any(), Undef()) => Any()
  case (Any(), Neg()) => Any()
  case (Any(), Zero()) => Any()
  case (Any(), Pos()) => Any()
  case (Any(), Nonnull()) => Any()
  case (Any(), Any()) => Any()
  case (Neg(), Any()) => Any()
  case (Zero(), Any()) => Any()
  case (Pos(), Any()) => Any()
  case (Nonnull(), Any()) => Any()
  case (Zero(), Pos()) => Neg()
  case (Zero(), Neg()) => Pos()
  case (Pos(), Neg()) => Pos()
  case (Neg(), Pos()) => Neg()
  case (Neg(), Zero()) => Neg()
  case (Zero(), Zero()) => Zero()
  case (Pos(), Zero()) => Pos()
  case (Nonnull(), Zero()) => Nonnull()
  case (Neg(), Neg()) => Any()
  case (Neg(), Nonnull()) => Any()
  case (Zero(), Nonnull()) => Any()
  case (Pos(), Pos()) => Any()
  case (Pos(), Nonnull()) => Any()
  case (Nonnull(), Neg()) => Any()
  case (Nonnull(), Pos()) => Any()
  case (Nonnull(), Nonnull()) => Any()
}

def plusabs6(x0: absint, uu: absint): absint = (x0, uu) match {
  case (Undef(), uu) => Any()
  case (Neg(), Undef()) => Any()
  case (Zero(), Undef()) => Any()
  case (Pos(), Undef()) => Any()
  case (Nonnull(), Undef()) => Any()
  case (Any(), Undef()) => Any()
  case (Any(), Neg()) => Any()
  case (Any(), Zero()) => Any()
  case (Any(), Pos()) => Any()
  case (Any(), Nonnull()) => Any()
  case (Any(), Any()) => Any()
  case (Neg(), Any()) => Any()
  case (Zero(), Any()) => Any()
  case (Pos(), Any()) => Any()
  case (Nonnull(), Any()) => Any()
  case (Zero(), Neg()) => Neg()
  case (Zero(), Zero()) => Zero()
  case (Zero(), Pos()) => Pos()
  case (Zero(), Nonnull()) => Nonnull()
  case (Neg(), Zero()) => Neg()
  case (Pos(), Zero()) => Pos()
  case (Nonnull(), Zero()) => Nonnull()
  case (Pos(), Pos()) => Pos()
  case (Neg(), Neg()) => Neg()
  case (Neg(), Pos()) => Any()
  case (Neg(), Nonnull()) => Any()
  case (Pos(), Neg()) => Any()
  case (Pos(), Nonnull()) => Any()
  case (Nonnull(), Neg()) => Any()
  case (Nonnull(), Pos()) => Any()
  case (Nonnull(), Nonnull()) => Any()
}

def lookup(x0: List[(List[Str.char], absint)], uu: List[Str.char]): absint =
  (x0, uu) match {
  case (Nil, uu) => Undef()
  case ((x, a) :: t, y) =>
    (if (Lista.equal_lista[Str.char](x, y)) a else lookup(t, y))
}

def evalabsexpr6(tab: List[(List[Str.char], absint)], x1: expression): absint =
  (tab, x1) match {
  case (tab, Constant(c)) =>
    (if (Int.less_int(c, Int.zero_int)) Neg()
      else (if (Int.equal_int(c, Int.zero_int)) Zero() else Pos()))
  case (tab, Variable(x)) => (lookup(tab, x) match {
                                case Neg() => Neg()
                                case Zero() => Zero()
                                case Pos() => Pos()
                                case Nonnull() => Nonnull()
                                case Any() => Any()
                                case Undef() => Nonnull()
                              })
  case (tab, Sum(e1, e2)) =>
    plusabs6(evalabsexpr6(tab, e1), evalabsexpr6(tab, e2))
  case (tab, Sub(e1, e2)) =>
    minusabs6(evalabsexpr6(tab, e1), evalabsexpr6(tab, e2))
}

def eval_const(x0: expression): option[Int.int] = x0 match {
  case Constant(c) => Some[Int.int](c)
  case Variable(uu) => None[Int.int]()
  case Sum(e1, e2) =>
    ((eval_const(e1), eval_const(e2)) match {
       case (None(), _) => None[Int.int]()
       case (Some(_), None()) => None[Int.int]()
       case (Some(v1), Some(v2)) => Some[Int.int](Int.plus_int(v1, v2))
     })
  case Sub(e1, e2) =>
    ((eval_const(e1), eval_const(e2)) match {
       case (None(), _) => None[Int.int]()
       case (Some(_), None()) => None[Int.int]()
       case (Some(v1), Some(v2)) => Some[Int.int](Int.minus_int(v1, v2))
     })
}

def evalcondabs6(tab: List[(List[Str.char], absint)], x1: condition):
      option[Boolean]
  =
  (tab, x1) match {
  case (tab, Eq(e1, e2)) =>
    ((eval_const(e1), eval_const(e2)) match {
       case (None(), _) =>
         ((evalabsexpr6(tab, e1), evalabsexpr6(tab, e2)) match {
            case (Neg(), Neg()) => None[Boolean]()
            case (Neg(), Zero()) => Some[Boolean](false)
            case (Neg(), Pos()) => None[Boolean]()
            case (Neg(), Nonnull()) => None[Boolean]()
            case (Neg(), Any()) => None[Boolean]()
            case (Neg(), Undef()) => None[Boolean]()
            case (Zero(), Neg()) => Some[Boolean](false)
            case (Zero(), Zero()) => Some[Boolean](true)
            case (Zero(), Pos()) => Some[Boolean](false)
            case (Zero(), Nonnull()) => Some[Boolean](false)
            case (Zero(), Any()) => None[Boolean]()
            case (Zero(), Undef()) => None[Boolean]()
            case (Pos(), Neg()) => None[Boolean]()
            case (Pos(), Zero()) => Some[Boolean](false)
            case (Pos(), Pos()) => None[Boolean]()
            case (Pos(), Nonnull()) => None[Boolean]()
            case (Pos(), Any()) => None[Boolean]()
            case (Pos(), Undef()) => None[Boolean]()
            case (Nonnull(), Neg()) => None[Boolean]()
            case (Nonnull(), Zero()) => Some[Boolean](false)
            case (Nonnull(), Pos()) => None[Boolean]()
            case (Nonnull(), Nonnull()) => None[Boolean]()
            case (Nonnull(), Any()) => None[Boolean]()
            case (Nonnull(), Undef()) => None[Boolean]()
            case (Any(), _) => None[Boolean]()
            case (Undef(), _) => None[Boolean]()
          })
       case (Some(_), None()) =>
         ((evalabsexpr6(tab, e1), evalabsexpr6(tab, e2)) match {
            case (Neg(), Neg()) => None[Boolean]()
            case (Neg(), Zero()) => Some[Boolean](false)
            case (Neg(), Pos()) => None[Boolean]()
            case (Neg(), Nonnull()) => None[Boolean]()
            case (Neg(), Any()) => None[Boolean]()
            case (Neg(), Undef()) => None[Boolean]()
            case (Zero(), Neg()) => Some[Boolean](false)
            case (Zero(), Zero()) => Some[Boolean](true)
            case (Zero(), Pos()) => Some[Boolean](false)
            case (Zero(), Nonnull()) => Some[Boolean](false)
            case (Zero(), Any()) => None[Boolean]()
            case (Zero(), Undef()) => None[Boolean]()
            case (Pos(), Neg()) => None[Boolean]()
            case (Pos(), Zero()) => Some[Boolean](false)
            case (Pos(), Pos()) => None[Boolean]()
            case (Pos(), Nonnull()) => None[Boolean]()
            case (Pos(), Any()) => None[Boolean]()
            case (Pos(), Undef()) => None[Boolean]()
            case (Nonnull(), Neg()) => None[Boolean]()
            case (Nonnull(), Zero()) => Some[Boolean](false)
            case (Nonnull(), Pos()) => None[Boolean]()
            case (Nonnull(), Nonnull()) => None[Boolean]()
            case (Nonnull(), Any()) => None[Boolean]()
            case (Nonnull(), Undef()) => None[Boolean]()
            case (Any(), _) => None[Boolean]()
            case (Undef(), _) => None[Boolean]()
          })
       case (Some(c1), Some(c2)) => Some[Boolean](Int.equal_int(c1, c2))
     })
}

def eval_const6(tab: List[(List[Str.char], absint)], x1: expression):
      option[Int.int]
  =
  (tab, x1) match {
  case (tab, Constant(c)) => Some[Int.int](c)
  case (tab, Variable(x)) =>
    (lookup(tab, x) match {
       case Neg() => None[Int.int]()
       case Zero() => None[Int.int]()
       case Pos() => None[Int.int]()
       case Nonnull() => None[Int.int]()
       case Any() => None[Int.int]()
       case Undef() => Some[Int.int](Int.uminus_int(Int.one_int))
     })
  case (tab, Sum(e1, e2)) =>
    ((eval_const6(tab, e1), eval_const6(tab, e2)) match {
       case (None(), _) => None[Int.int]()
       case (Some(_), None()) => None[Int.int]()
       case (Some(v1), Some(v2)) => Some[Int.int](Int.plus_int(v1, v2))
     })
  case (tab, Sub(e1, e2)) =>
    ((eval_const6(tab, e1), eval_const6(tab, e2)) match {
       case (None(), _) => None[Int.int]()
       case (Some(_), None()) => None[Int.int]()
       case (Some(v1), Some(v2)) => Some[Int.int](Int.minus_int(v1, v2))
     })
}

def joinabs(x0: absint, uu: absint): absint = (x0, uu) match {
  case (Any(), uu) => Any()
  case (Neg(), Any()) => Any()
  case (Zero(), Any()) => Any()
  case (Pos(), Any()) => Any()
  case (Nonnull(), Any()) => Any()
  case (Undef(), Any()) => Any()
  case (Undef(), Neg()) => Any()
  case (Undef(), Zero()) => Any()
  case (Undef(), Pos()) => Any()
  case (Undef(), Nonnull()) => Any()
  case (Undef(), Undef()) => Any()
  case (Neg(), Undef()) => Any()
  case (Zero(), Undef()) => Any()
  case (Pos(), Undef()) => Any()
  case (Nonnull(), Undef()) => Any()
  case (Zero(), Zero()) => Zero()
  case (Pos(), Pos()) => Pos()
  case (Neg(), Neg()) => Neg()
  case (Nonnull(), Nonnull()) => Nonnull()
  case (Neg(), Zero()) => Any()
  case (Neg(), Pos()) => Any()
  case (Neg(), Nonnull()) => Any()
  case (Zero(), Neg()) => Any()
  case (Zero(), Pos()) => Any()
  case (Zero(), Nonnull()) => Any()
  case (Pos(), Neg()) => Any()
  case (Pos(), Zero()) => Any()
  case (Pos(), Nonnull()) => Any()
  case (Nonnull(), Neg()) => Any()
  case (Nonnull(), Zero()) => Any()
  case (Nonnull(), Pos()) => Any()
}

def jointab(x0: List[(List[Str.char], absint)],
             t2: List[(List[Str.char], absint)]):
      List[(List[Str.char], absint)]
  =
  (x0, t2) match {
  case (Nil, t2) =>
    Lista.map[(List[Str.char], absint),
               (List[Str.char],
                 absint)](((a: (List[Str.char], absint)) =>
                            {
                              val (x, aa) = a: ((List[Str.char], absint));
                              (x, joinabs(Undef(), aa))
                            }),
                           t2)
  case ((x, a) :: t1, t2) =>
    update(jointab(t1, t2), x, joinabs(a, lookup(t2, x)))
}

def san6_stmt(tab: List[(List[Str.char], absint)], x1: statement):
      option[List[(List[Str.char], absint)]]
  =
  (tab, x1) match {
  case (tab, Skip) => Some[List[(List[Str.char], absint)]](tab)
  case (tab, Print(uu)) => Some[List[(List[Str.char], absint)]](tab)
  case (tab, Read(x)) =>
    Some[List[(List[Str.char], absint)]](update(tab, x, Any()))
  case (tab, Aff(x, e)) =>
    Some[List[(List[Str.char], absint)]](update(tab, x, evalabsexpr6(tab, e)))
  case (tab, Exec(e)) =>
    (eval_const6(tab, e) match {
       case None() =>
         (if (safeexecabs6(evalabsexpr6(tab, e)))
           Some[List[(List[Str.char], absint)]](tab)
           else None[List[(List[Str.char], absint)]]())
       case Some(c) =>
         (if (! (Int.equal_int(c, Int.zero_int)))
           Some[List[(List[Str.char], absint)]](tab)
           else None[List[(List[Str.char], absint)]]())
     })
  case (tab, Seq(s1, s2)) =>
    (san6_stmt(tab, s1) match {
       case None() => None[List[(List[Str.char], absint)]]()
       case Some(t1) => san6_stmt(t1, s2)
     })
  case (tab, If(c, s1, s2)) =>
    {
      val tabT = refine_true6(c, tab): (List[(List[Str.char], absint)])
      val tabF = refine_false6(c, tab): (List[(List[Str.char], absint)]);
      (evalcondabs6(tab, c) match {
         case None() =>
           ((san6_stmt(tabT, s1), san6_stmt(tabF, s2)) match {
              case (None(), _) => None[List[(List[Str.char], absint)]]()
              case (Some(_), None()) => None[List[(List[Str.char], absint)]]()
              case (Some(t1), Some(t2)) =>
                Some[List[(List[Str.char], absint)]](jointab(t1, t2))
            })
         case Some(true) => san6_stmt(tabT, s1)
         case Some(false) => san6_stmt(tabF, s2)
       })
    }
}

def san6(s: statement): Boolean =
  ! (equal_option[List[(List[Str.char],
                         absint)]](san6_stmt(Nil, s),
                                    None[List[(List[Str.char], absint)]]()))

} /* object tp67 */
