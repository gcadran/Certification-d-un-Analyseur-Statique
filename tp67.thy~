theory tp67
imports Main  "~~/src/HOL/Library/Code_Target_Int" 
begin

(* Types des expressions, conditions et programmes (statement) *)
datatype expression= Constant int | Variable string | Sum expression expression | Sub expression expression

datatype condition= Eq expression expression

datatype statement= Seq statement statement | 
                    Aff string expression | 
                    Read string | 
                    Print expression | 
                    Exec expression | 
                    If condition statement statement |
                    Skip
(* Un exemple d'expression *)

(* expr1= (x-10) *)
definition "expr1= (Sub (Variable ''x'') (Constant 10))"


(* Des exemples de programmes *)

(* p1= exec(0) *)
definition "p1= Exec (Constant 0)"

(* p2= {
        print(10)
        exec(0+0)
       }
*)

definition "p2= (Seq (Print (Constant 10)) (Exec (Sum (Constant 0) (Constant 0))))"

(* p3= {
         x:=0
         exec(x)
       }
*)

definition "p3= (Seq (Aff ''x'' (Constant 0)) (Exec (Variable ''x'')))"

(* p4= {
         read(x)
         print(x+1)
       }
*)
definition "p4= (Seq (Read ''x'') (Print (Sum (Variable ''x'') (Constant 1))))"


(* Le type des evenements soit X: execute, soit P: print *)
datatype event= X int | P int

(* les flux de sortie, d'entree et les tables de symboles *)

type_synonym outchan= "event list"
definition "el1= [X 1, P 10, X 0, P 20]"                   (* Un exemple de flux de sortie *)

type_synonym inchan= "int list"           
definition "il1= [1,-2,10]"                                (* Un exemple de flux d'entree [1,-2,10]              *)

type_synonym symTable= "(string * int) list"
definition "(st1::symTable)= [(''x'',10),(''y'',12)]"      (* Un exemple de table de symbole *)


(* La fonction (partielle) de recherche dans une liste de couple, par exemple une table de symbole *)
datatype 'a option= None | Some 'a

fun assoc:: "'a \<Rightarrow> ('a * 'b) list \<Rightarrow> 'b option"
where
"assoc _ [] = None" |
"assoc x1 ((x,y)#xs)= (if x=x1 then Some(y) else (assoc x1 xs))"

(* Exemples de recherche dans une table de symboles *)

value "assoc ''x'' st1"     (* quand la variable est dans la table st1 *)
value "assoc ''z'' st1"     (* quand la variable n'est pas dans la table st1 *)



(* Evaluation des expressions par rapport a une table de symboles *)
fun evalE:: "expression \<Rightarrow> symTable \<Rightarrow> int"
where
"evalE (Constant s) e = s" |
"evalE (Variable s) e= (case (assoc s e) of None \<Rightarrow> -1 | Some(y) \<Rightarrow> y)" |
"evalE (Sum e1 e2) e= ((evalE e1 e) + (evalE e2 e))" |
"evalE (Sub e1 e2) e= ((evalE e1 e) - (evalE e2 e))" 

(* Exemple d'√©valuation d'expression *)

value "evalE expr1 st1"

(* Evaluation des conditions par rapport a une table de symboles *)
fun evalC:: "condition \<Rightarrow> symTable \<Rightarrow> bool"
where
"evalC (Eq e1 e2) t= ((evalE e1 t) = (evalE e2 t))"

(* Evaluation d'un programme par rapport a une table des symboles, a un flux d'entree et un flux de sortie. 
   Rend un triplet: nouvelle table des symboles, nouveaux flux d'entree et sortie *)
fun evalS:: "statement \<Rightarrow> (symTable * inchan * outchan) \<Rightarrow> (symTable * inchan * outchan)"
where
"evalS Skip x=x" |
"evalS (Aff s e)  (t,inch,outch)=  (((s,(evalE e t))#t),inch,outch)" |
"evalS (If c s1 s2)  (t,inch,outch)=  (if (evalC c t) then (evalS s1 (t,inch,outch)) else (evalS s2 (t,inch,outch)))" |
"evalS (Seq s1 s2) (t,inch,outch)= 
    (let (t2,inch2,outch2)= (evalS s1 (t,inch,outch)) in
        evalS s2 (t2,inch2,outch2))" |
"evalS (Read _) (t,[],outch)= (t,[],outch)" |
"evalS (Read s) (t,(x#xs),outch)= (((s,x)#t),xs,outch)" |
"evalS (Print e) (t,inch,outch)= (t,inch,((P (evalE e t))#outch))" |
"evalS (Exec e) (t,inch,outch)= 
  (let res= evalE e t in
   (t,inch,((X res)#outch)))"



(* Exemples d'√©valuation de programmes *)
(* Les programmes p1, p2, p3, p4 ont √©t√© d√©finis plus haut *)
(* p1= exec(0) *)

value "evalS p1 ([],[],[])"

(* ------------------------------------ *)
(* p2= {
        print(10)
        exec(0+0)
       }
*)

value "evalS p2 ([],[],[])"

(* ------------------------------------ *)
(* p3= {
         x:=0
         exec(x)
       }
*)

value "evalS p3 ([],[],[])"

(* ------------------------------------ *)
(* p4= {
         read(x)
         print(x+1)
       }
*)

value "evalS p4 ([],[10],[])"


definition "bad1= (Exec (Constant 0))"
definition "bad2= (Exec (Sub (Constant 2) (Constant 2)))"
definition "bad3= (Seq (Aff ''x'' (Constant 1)) (Seq (Print (Variable ''x'')) (Exec (Sub (Variable ''x'') (Constant 1)))))"
definition "bad4= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) Skip (Aff ''y'' (Constant 1))) (Exec (Sum (Variable ''y'') (Constant 1)))))"
definition "bad5= (Seq (Read ''x'') (Seq (Aff ''y'' (Sum (Variable ''x'') (Constant 2))) (Seq (If (Eq (Variable ''x'') (Sub (Constant 0) (Constant 1))) (Seq (Aff ''x'' (Sum (Variable ''x'') (Constant 2))) (Aff ''y'' (Sub (Variable ''y'') (Variable ''x'')))) (Seq (Aff ''x'' (Sub (Variable ''x'') (Constant 2))) (Aff ''y'' (Sub (Variable ''y'') (Variable ''x''))))) (Exec (Variable ''y'')))))"
definition "bad6= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''z'' (Constant 1)) (Aff ''z'' (Constant 0))) (Exec (Variable ''z''))))"
definition "bad7= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''z'' (Constant 0)) (Aff ''z'' (Constant 1))) (Exec (Variable ''z''))))"
definition "bad8= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Variable ''x'') (Variable ''y'')) (Exec (Constant 1)) (Exec (Constant 0)))))"
definition "bad9= (Seq (Read ''y'') (Seq (If (Eq (Variable ''y'') (Constant 0)) (Aff ''x'' (Constant 1)) (Aff ''x'' (Constant 2))) (Seq (If (Eq (Variable ''y'') (Constant 0)) (Aff ''z'' (Constant 0)) (Aff ''z'' (Constant 2))) (If (Eq (Variable ''x'') (Variable ''z'')) (Exec (Constant 1)) (Exec (Constant 0))))))"

definition "ok0= (Seq (Aff ''x'' (Constant 1)) (Seq (Read ''y'') (Seq (If (Eq (Variable ''y'') (Constant 0)) (Seq (Print (Sum (Variable ''y'') (Variable ''x'')))
(Print (Variable ''x''))
) (Print (Variable ''y''))
) (Seq (Aff ''x'' (Constant 1)) (Seq (Print (Variable ''x''))
 (Seq (Aff ''x'' (Constant 2)) (Seq (Print (Variable ''x''))
 (Seq (Aff ''x'' (Constant 3)) (Seq (Print (Variable ''x''))
 (Seq (Read ''y'') (Seq (If (Eq (Variable ''y'') (Constant 0)) (Aff ''z'' (Sum (Variable ''x'') (Variable ''x''))) (Aff ''z'' (Sub (Variable ''x'') (Variable ''y'')))) (Print (Variable ''z''))
)))))))))))"
definition "ok1= (Seq (Aff ''x'' (Constant 1)) (Seq (Print (Sum (Variable ''x'') (Variable ''x'')))
 (Seq (Exec (Constant 10)) (Seq (Read ''y'') (If (Eq (Variable ''y'') (Constant 0)) (Exec (Constant 1)) (Exec (Constant 2)))))))"
definition "ok2= (Exec (Variable ''y''))"
definition "ok3= (Seq (Read ''x'') (Exec (Sum (Variable ''y'') (Constant 2))))"
definition "ok4= (Seq (Aff ''x'' (Constant 0)) (Seq (Aff ''x'' (Sum (Variable ''x'') (Constant 20))) (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''z'' (Constant 0)) (Aff ''z'' (Constant 4))) (Seq (Exec (Variable ''z'')) (Exec (Variable ''x''))))))"
definition "ok5= (Seq (Read ''x'') (Seq (Aff ''x'' (Constant 4)) (Exec (Variable ''x''))))"
definition "ok6= (Seq (If (Eq (Constant 1) (Constant 2)) (Aff ''x'' (Constant 0)) (Aff ''x'' (Constant 1))) (Exec (Variable ''x'')))"
definition "ok7= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''x'' (Constant 1)) (If (Eq (Variable ''x'') (Constant 4)) (Aff ''x'' (Constant 1)) (Aff ''x'' (Constant 1)))) (Exec (Variable ''x''))))"
definition "ok8= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''x'' (Constant 1)) (Aff ''x'' (Constant 2))) (Exec (Sub (Variable ''x'') (Constant 3)))))"
definition "ok9= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Sum (Variable ''x'') (Variable ''y'')) (Constant 0)) (Exec (Constant 1)) (Exec (Sum (Variable ''x'') (Sum (Variable ''y'') (Sum (Variable ''y'') (Variable ''x''))))))))"
definition "ok10= (Seq (Read ''x'') (If (Eq (Variable ''x'') (Constant 0)) (Exec (Constant 1)) (Exec (Variable ''x''))))"
definition "ok11= (Seq (Read ''x'') (Seq (If (Eq (Variable ''x'') (Constant 0)) (Aff ''x'' (Sum (Variable ''x'') (Constant 1))) Skip) (Exec (Variable ''x''))))"
definition "ok12= (Seq (Aff ''x'' (Constant 1)) (Seq (Read ''z'') (If (Eq (Variable ''z'') (Constant 0)) (Exec (Variable ''y'')) (Exec (Variable ''z'')))))"
definition "ok13= (Seq (Aff ''z'' (Constant 4)) (Seq (Aff ''x'' (Constant 1)) (Seq (Read ''y'') (Seq (Aff ''x'' (Sum (Variable ''x'') (Sum (Variable ''z'') (Variable ''x'')))) (Seq (Aff ''z'' (Sum (Variable ''z'') (Variable ''x''))) (Seq (If (Eq (Variable ''y'') (Constant 1)) (Aff ''x'' (Sub (Variable ''x'') (Variable ''y''))) Skip) (Seq (If (Eq (Variable ''y'') (Constant 0)) (Seq (Aff ''y'' (Sum (Variable ''y'') (Constant 1))) (Exec (Variable ''x''))) Skip) (Exec (Variable ''y'')))))))))"
definition "ok14= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Sum (Variable ''x'') (Variable ''y'')) (Constant 0)) (Exec (Constant 1)) (Exec (Sum (Variable ''x'') (Variable ''y''))))))"
definition "ok15= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Sum (Variable ''x'') (Variable ''y'')) (Constant 0)) (Exec (Constant 1)) (Exec (Sum (Variable ''x'') (Sum (Variable ''y'') (Sum (Variable ''y'') (Variable ''x''))))))))"
definition "ok16= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Sum (Variable ''x'') (Variable ''y'')) (Sum (Variable ''y'') (Variable ''x''))) (Exec (Constant 1)) (Exec (Constant 0)))))"
definition "ok17= (Seq (Read ''x'') (Seq (Read ''y'') (If (Eq (Sum (Constant 10) (Sub (Sum (Variable ''x'') (Variable ''y'')) (Constant 3))) (Sub (Sum (Variable ''y'') (Variable ''x'')) (Sub (Variable ''x'') (Sum (Variable ''x'') (Constant 7))))) (Exec (Constant 1)) (Exec (Sum (Variable ''x'') (Variable ''y''))))))"

(* Le TP commence ici! *)
(* TODO: BAD, san0, lemme de correction *)

fun san0::"statement \<Rightarrow> bool"
  where
"san0  (Exec expr) = False " |
"(san0 (Seq stat1 stat2)) = (san0 stat1 \<and> san0 stat2) "|
"san0 (If cond s1 s2) = (san0 s1 \<and> san0 s2)"|
"san0 _ = True"


fun san1::"statement \<Rightarrow> bool"
  where
"san1 (Exec (Variable _ )) = False"
|"san1 (Exec (Constant c)) = (c \<noteq> 0) "
|"san1 (Exec (Sum _ _ )) = False"
|"san1 (Exec (Sub _ _ )) = False"
|"san1 (Seq s1 s2) = (san1 s1 \<and> san1 s2)"
|"san1 (If _  s1 s2) = (san1 s1 \<and> san1 s2)"
|"san1 _ = True"

fun eval_const :: "expression \<Rightarrow> int option" where
"eval_const (Constant c) = Some c" |
"eval_const (Variable _) = None" |
"eval_const (Sum e1 e2) =
   (case (eval_const e1, eval_const e2) of
      (Some v1, Some v2) \<Rightarrow> Some (v1 + v2)
    | _ \<Rightarrow> None)" |
"eval_const (Sub e1 e2) =
   (case (eval_const e1, eval_const e2) of
      (Some v1, Some v2) \<Rightarrow> Some (v1 - v2)
    | _ \<Rightarrow> None)"

fun san2 :: "statement \<Rightarrow> bool" where
"san2 (Exec e) =
   (case eval_const e of
      Some c \<Rightarrow> (c \<noteq> 0)
    | None   \<Rightarrow> False)"

| "san2 (Seq s1 s2) = (san2 s1 \<and> san2 s2)"
| "san2 (If _ s1 s2) = (san2 s1 \<and> san2 s2)"
| "san2 _ = True"




datatype absInt = Neg | Zero | Pos | NonNull | Any | Undef

type_synonym tabSan = "(string * absInt) list"

fun lookup :: "tabSan \<Rightarrow> string \<Rightarrow> absInt" where
"lookup [] _ = Undef" |
"lookup ((x,a)#t) y = (if x = y then a else lookup t y)"

fun update :: "tabSan \<Rightarrow> string \<Rightarrow> absInt \<Rightarrow> tabSan" where
"update [] x a = [(x,a)]" |
"update ((y,b)#t) x a =
   (if x = y then (x,a)#t else (y,b)#update t x a)"

(* plusAbs / minusAbs *)
fun plusAbs :: "absInt \<Rightarrow> absInt \<Rightarrow> absInt" where
"plusAbs Undef _ = Any" |
"plusAbs _ Undef = Any" |
"plusAbs Any _ = Any" |
"plusAbs _ Any = Any" |
"plusAbs Zero a = a" |
"plusAbs a Zero = a" |
"plusAbs Pos Pos = Pos" |
"plusAbs Neg Neg = Neg" |
"plusAbs _ _ = Any"

fun minusAbs :: "absInt \<Rightarrow> absInt \<Rightarrow> absInt" where
"minusAbs Undef _ = Any" |
"minusAbs _ Undef = Any" |
"minusAbs Any _ = Any" |
"minusAbs _ Any = Any" |
"minusAbs Zero Pos = Neg" |
"minusAbs Zero Neg = Pos" |
"minusAbs Pos Neg = Pos" |
"minusAbs Neg Pos = Neg" |
"minusAbs a Zero = a" |
"minusAbs _ _ = Any"

(* √©valuation abstraite des expressions *)

fun evalAbsExpr :: "tabSan \<Rightarrow> expression \<Rightarrow> absInt" where
"evalAbsExpr tab (Constant c) =
   (if c < 0 then Neg else if c = 0 then Zero else Pos)" |

(* ATTENTION : variable non d√©finie \<Rightarrow> Undef \<Rightarrow> NonNull
   car evalE renvoie -1 dans ce cas *)
"evalAbsExpr tab (Variable x) =
   (case lookup tab x of
      Undef \<Rightarrow> NonNull
    | a \<Rightarrow> a)" |

"evalAbsExpr tab (Sum e1 e2) =
   plusAbs (evalAbsExpr tab e1) (evalAbsExpr tab e2)" |

"evalAbsExpr tab (Sub e1 e2) =
   minusAbs (evalAbsExpr tab e1) (evalAbsExpr tab e2)"

(* raffinement pour If *)

fun refine_true :: "condition \<Rightarrow> tabSan \<Rightarrow> tabSan" where
"refine_true (Eq (Variable x) (Constant n)) tab =
   (if n = 0 then update tab x Zero else tab)" |
"refine_true (Eq (Constant n) (Variable x)) tab =
   (if n = 0 then update tab x Zero else tab)" |
"refine_true _ tab = tab"

fun refine_false :: "condition \<Rightarrow> tabSan \<Rightarrow> tabSan" where
"refine_false (Eq (Variable x) (Constant n)) tab =
   (if n = 0 then update tab x NonNull else tab)" |
"refine_false (Eq (Constant n) (Variable x)) tab =
   (if n = 0 then update tab x NonNull else tab)" |
"refine_false _ tab = tab"

(* join abstrait *)

fun joinAbs :: "absInt \<Rightarrow> absInt \<Rightarrow> absInt" where
"joinAbs Any _ = Any" |
"joinAbs _ Any = Any" |
"joinAbs Undef _ = Any" |
"joinAbs _ Undef = Any" |
"joinAbs Zero Zero = Zero" |
"joinAbs Pos Pos = Pos" |
"joinAbs Neg Neg = Neg" |
"joinAbs NonNull NonNull = NonNull" |
"joinAbs _ _ = Any"

fun joinTab :: "tabSan \<Rightarrow> tabSan \<Rightarrow> tabSan" where
"joinTab [] t2 =
   map (\<lambda>(x,a). (x, joinAbs Undef a)) t2" |
"joinTab ((x,a)#t1) t2 =
   update (joinTab t1 t2) x (joinAbs a (lookup t2 x))"

(* condition abstraite *)
fun evalCondAbs :: "tabSan \<Rightarrow> condition \<Rightarrow> bool option" where
"evalCondAbs tab (Eq e1 e2) =
   (case (eval_const e1, eval_const e2) of
      (Some c1, Some c2) \<Rightarrow> Some (c1 = c2)
    | _ \<Rightarrow>
        (case (evalAbsExpr tab e1, evalAbsExpr tab e2) of
           (Zero, Zero) \<Rightarrow> Some True
         | (Zero, _) \<Rightarrow> Some False
         | (_, Zero) \<Rightarrow> Some False
         | _ \<Rightarrow> None))"

(* s√ªret√© d‚Äôun Exec abstrait *)
fun safeExecAbs :: "absInt \<Rightarrow> bool" where
"safeExecAbs Zero = False" |
"safeExecAbs Any = False" |
"safeExecAbs Undef = False" |
"safeExecAbs Pos = True" |
"safeExecAbs Neg = True" |
"safeExecAbs NonNull = True"

(* analyseur san4 *)

fun san4_stmt :: "tabSan \<Rightarrow> statement \<Rightarrow> tabSan option" where
"san4_stmt tab Skip = Some tab" |
"san4_stmt tab (Print _) = Some tab" |

(* üî¥ CORRECTION IMPORTANTE :
   apr√®s Read, x peut valoir n‚Äôimporte quoi \<rightarrow> Any, pas NonNull *)
"san4_stmt tab (Read x) =
   Some (update tab x Any)" |

"san4_stmt tab (Aff x e) =
   Some (update tab x (evalAbsExpr tab e))" |

"san4_stmt tab (Exec e) =
   (case eval_const e of
      Some c \<Rightarrow> (if c \<noteq> 0 then Some tab else None)
    | None \<Rightarrow> (if safeExecAbs (evalAbsExpr tab e)
              then Some tab else None))" |

"san4_stmt tab (Seq s1 s2) =
   (case san4_stmt tab s1 of
      None \<Rightarrow> None
    | Some t1 \<Rightarrow> san4_stmt t1 s2)" |

(* If : toujours les deux branches + join, comme demand√© par le JAR *)
"san4_stmt tab (If c s1 s2) =
   (let tabT = refine_true c tab;
        tabF = refine_false c tab
    in case (san4_stmt tabT s1, san4_stmt tabF s2) of
         (Some t1, Some t2) \<Rightarrow> Some (joinTab t1 t2)
       | _ \<Rightarrow> None)"

definition san4 :: "statement \<Rightarrow> bool" where
"san4 s \<equiv> (san4_stmt [] s \<noteq> None)"

value "zip [1::nat, 2, 3, 4, 5, 6, 7, 8, 9] (map san4 [bad1, bad2, bad3, bad4, bad5, bad6, bad7, bad8, bad9])"

value "zip [0::nat, 1, 2, 3, 4, 5, 6, 7, 8] (map san4 [ok0, ok1, ok2, ok3, ok4, ok5, ok6, ok7, ok8])"



(* lookup pour san5 : variables non vues = NonNull *)
fun lookup5 :: "tabSan \<Rightarrow> string \<Rightarrow> absInt" where
"lookup5 [] _ = NonNull" |
"lookup5 ((x,a)#t) y = (if x = y then a else lookup5 t y)"

(* ====================================================== *)
(* op√©rateurs abstraits d√©di√©s √† san5 (NE PAS TOUCHER SAN4) *)
(* ====================================================== *)

fun plusAbs5 :: "absInt \<Rightarrow> absInt \<Rightarrow> absInt" where
"plusAbs5 Undef _ = Any" |
"plusAbs5 _ Undef = Any" |
"plusAbs5 Any _ = Any" |
"plusAbs5 _ Any = Any" |

(* cas s√ªrs *)
"plusAbs5 Zero a = a" |
"plusAbs5 a Zero = a" |
"plusAbs5 Pos Pos = Pos" |
"plusAbs5 Neg Neg = Neg" |

(* cas impliquant NonNull *)
"plusAbs5 Pos NonNull = NonNull" |
"plusAbs5 NonNull Pos = NonNull" |
"plusAbs5 Neg NonNull = NonNull" |
"plusAbs5 NonNull Neg = NonNull" |

(* tout le reste = inconnu *)
"plusAbs5 _ _ = Any"

fun minusAbs5 :: "absInt \<Rightarrow> absInt \<Rightarrow> absInt" where
"minusAbs5 Undef _ = Any" |
"minusAbs5 _ Undef = Any" |
"minusAbs5 Any _ = Any" |
"minusAbs5 _ Any = Any" |

(* cas exacts s√ªrs *)
"minusAbs5 a Zero = a" |
"minusAbs5 Pos Neg = Pos" |
"minusAbs5 Neg Pos = Neg" |

(* cas impliquant NonNull *)
"minusAbs5 Pos NonNull = NonNull" |
"minusAbs5 Neg NonNull = NonNull" |

(* les autres cas impossible √† d√©terminer *)
"minusAbs5 _ _ = Any"

(* ====================================================== *)
(* √âvaluation abstraite san5 *)
(* ====================================================== *)

fun evalAbsExpr5 :: "tabSan \<Rightarrow> expression \<Rightarrow> absInt" where
"evalAbsExpr5 tab (Constant c) =
   (if c < 0 then Neg else if c = 0 then Zero else Pos)" |

"evalAbsExpr5 tab (Variable x) =
   lookup5 tab x" |

"evalAbsExpr5 tab (Sum e1 e2) =
   plusAbs5 (evalAbsExpr5 tab e1) (evalAbsExpr5 tab e2)" |

"evalAbsExpr5 tab (Sub e1 e2) =
   minusAbs5 (evalAbsExpr5 tab e1) (evalAbsExpr5 tab e2)"

(* ====================================================== *)
(* Raffinement des branches pour les IF *)
(* ====================================================== *)

fun refine_true5 :: "condition \<Rightarrow> tabSan \<Rightarrow> tabSan" where
"refine_true5 (Eq (Variable x) (Constant n)) tab =
   (if n = 0 then update tab x Zero else tab)" |
"refine_true5 (Eq (Constant n) (Variable x)) tab =
   (if n = 0 then update tab x Zero else tab)" |
"refine_true5 _ tab = tab"

fun refine_false5 :: "condition \<Rightarrow> tabSan \<Rightarrow> tabSan" where
"refine_false5 (Eq (Variable x) (Constant n)) tab =
   (if n = 0 then update tab x NonNull else tab)" |
"refine_false5 (Eq (Constant n) (Variable x)) tab =
   (if n = 0 then update tab x NonNull else tab)" |
"refine_false5 _ tab = tab"

(* ====================================================== *)
(* √âvaluation abstraite des conditions pour san5 *)
(* ====================================================== *)

fun evalCondAbs5 :: "tabSan \<Rightarrow> condition \<Rightarrow> bool option" where
"evalCondAbs5 tab (Eq e1 e2) =
   (case (eval_const e1, eval_const e2) of
      (Some c1, Some c2) \<Rightarrow> Some (c1 = c2)
    | _ \<Rightarrow>
       (case (evalAbsExpr5 tab e1, evalAbsExpr5 tab e2) of
          (Zero, Zero) \<Rightarrow> Some True
        | (Zero, NonNull) \<Rightarrow> Some False
        | (Zero, Pos) \<Rightarrow> Some False
        | (Zero, Neg) \<Rightarrow> Some False
        | (NonNull, Zero) \<Rightarrow> Some False
        | (Pos, Zero) \<Rightarrow> Some False
        | (Neg, Zero) \<Rightarrow> Some False
        | _ \<Rightarrow> None))"

(* ====================================================== *)
(* S√©curit√© Exec pour san5 *)
(* ====================================================== *)

fun safeExecAbs5 :: "absInt \<Rightarrow> bool" where
"safeExecAbs5 Zero = False" |
"safeExecAbs5 Any = False" |
"safeExecAbs5 Undef = False" |
"safeExecAbs5 Pos = True" |
"safeExecAbs5 Neg = True" |
"safeExecAbs5 NonNull = True"

(* ====================================================== *)
(* Analyseur principal san5 *)
(* ====================================================== *)

fun san5_stmt :: "tabSan \<Rightarrow> statement \<Rightarrow> tabSan option" where

"san5_stmt tab Skip = Some tab" |

"san5_stmt tab (Print _) = Some tab" |

"san5_stmt tab (Read x) =
   Some (update tab x Any)" |

"san5_stmt tab (Aff x e) =
   Some (update tab x (evalAbsExpr5 tab e))" |

"san5_stmt tab (Exec e) =
   (case eval_const e of
      Some c \<Rightarrow> (if c \<noteq> 0 then Some tab else None)
    | None \<Rightarrow> (if safeExecAbs5 (evalAbsExpr5 tab e)
              then Some tab else None))" |

"san5_stmt tab (Seq s1 s2) =
   (case san5_stmt tab s1 of
      None \<Rightarrow> None
    | Some t1 \<Rightarrow> san5_stmt t1 s2)" |

"san5_stmt tab (If c s1 s2) =
   (let tabT = refine_true5 c tab;
        tabF = refine_false5 c tab
    in case evalCondAbs5 tab c of
         Some True \<Rightarrow> san5_stmt tabT s1
       | Some False \<Rightarrow> san5_stmt tabF s2
       | None \<Rightarrow>
           (case (san5_stmt tabT s1, san5_stmt tabF s2) of
              (Some t1, Some t2) \<Rightarrow> Some (joinTab t1 t2)
            | _ \<Rightarrow> None))"

definition san5 :: "statement \<Rightarrow> bool" where
"san5 s \<equiv> (san5_stmt [] s \<noteq> None)"



value "zip [1::nat, 2, 3, 4, 5, 6, 7, 8, 9] (map san5 [bad1, bad2, bad3, bad4, bad5, bad6, bad7, bad8, bad9])"

value "zip [0::nat, 1, 2, 3, 4, 5, 6, 7, 8] (map san5 [ok0, ok1, ok2, ok3, ok4, ok5, ok6, ok7, ok8])"






fun BAD::"(symTable * inchan * outchan) \<Rightarrow>  bool"
  where
"BAD (_,_,outch) = (List.member outch (X 0))"

(* Si san accepte un programme alors son √©valuation, quelles que soient les entr√©es utilisateur (inchan)
   ne provoquera pas d'exec(0) *)





lemma full_correction_san0:
  "san0 s \<Longrightarrow> \<not> BAD st \<Longrightarrow> \<not> BAD (evalS s st)"

  nitpick
 apply (induction s arbitrary: st)
      apply (simp_all add: BAD.simps evalS.simps Let_def
                            member_rec(1) member_rec(2))
      apply auto
     apply (metis BAD.elims(3))

    apply (metis BAD.simps evalS.simps(5) evalS.simps(6) neq_Nil_conv)

   apply (simp add: member_rec(1))

  by presburger
  



lemma correction_san0:
  "san0 s \<Longrightarrow> \<not> BAD (evalS s (t,inch,[]))"

apply (rule full_correction_san0)
  apply (simp add: BAD.simps evalS.simps split: if_splits)
  apply (simp add: BAD.simps)
  by (simp add: member_rec(2))

lemma full_correction_san1:
  "san1 s \<Longrightarrow> \<not> BAD st \<Longrightarrow> \<not> BAD (evalS s st)"
apply (induction s arbitrary: st)
       apply (simp_all add: BAD.simps evalS.simps Let_def
                            member_rec(1) member_rec(2)
                      split: if_splits)
  apply auto
      apply (metis BAD.elims(3))
     apply (simp add: full_correction_san0)
    apply (simp add: member_rec(1))
  apply (rename_tac x a b)
  apply (case_tac x)
      apply (simp_all add: san1.simps evalE.simps member_rec(1) member_rec(2))
  by presburger


lemma correction_san1:
  "san1 s \<Longrightarrow> \<not> BAD (evalS s (t,inch,[]))"
apply (rule full_correction_san1)
   apply assumption
  apply (simp add: BAD.simps member_rec(2))
done


(* ----- Restriction de l'export Scala (Isabelle 2023) -------*)
(* ! ! !  NE PAS MODIFIER ! ! ! *)
(* Suppression de l'export des abstract datatypes (Isabelle 2023) *)
code_reserved Scala
  expression condition statement 
code_printing
   type_constructor expression \<rightharpoonup> (Scala) "expression"
  | constant Constant \<rightharpoonup> (Scala) "Constant"
  | constant Variable \<rightharpoonup> (Scala) "Variable"
  | constant Sum \<rightharpoonup> (Scala) "Sum"
  | constant Sub \<rightharpoonup> (Scala) "Sub"  

  | type_constructor condition \<rightharpoonup> (Scala) "condition"
  | constant Eq \<rightharpoonup> (Scala) "Eq"

  | type_constructor statement \<rightharpoonup> (Scala) "statement"
  | constant Seq \<rightharpoonup> (Scala) "Seq"
  | constant Aff \<rightharpoonup> (Scala) "Aff"
  | constant Read \<rightharpoonup> (Scala) "Read"
  | constant Print \<rightharpoonup> (Scala) "Print"
  | constant Exec \<rightharpoonup> (Scala) "Exec"
  | constant If \<rightharpoonup> (Scala) "If"
  | constant Skip \<rightharpoonup> (Scala) "Skip"
  | code_module "" \<rightharpoonup> (Scala) 
\<open>// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion {
  implicit def int2int(i: utilities.Datatype.Int.int): Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i) => Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
     else {
       val (r, s): (BigInt, BigInt) =
         (
             (k: BigInt) =>
               (l: BigInt) =>
                 if (l == 0) (BigInt(0), k)
                 else
                   (k.abs /% l.abs)
         ).apply(k).apply(BigInt(2));
       ((if (BigInt(0) < k) r else (-r) - s), s == BigInt(1))
     })

  def char_of_integer(k: BigInt): Str.char = {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    Str.Chara(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil)     => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[Str.char] = {
    (l.map(c => {
      val k: Int = c.toInt;
      if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal")
    }))
      .map(a => char_of_integer(a))
  }

  def explode(s: String): List[Str.char] = {
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s: String): List[Str.char] = explode(s)

  // conversion from Scala List[Char] to HOL List[Str.char]
  implicit def charList2charList(l: List[Char]): List[Str.char] =
    explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[Str.char] on first position
  implicit def tupleString2tupleString[T](
      t: (List[Char], T)
  ): (List[Str.char], T) = t match {
    case (e1, e2) => (charList2charList(e1), e2)
  }

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2dataint(i: Int.int): utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i) => utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: Str.char): Char = {
    x match {
      case Str.Chara(x1, x2, x3, x4, x5, x6, x7, x8) => {
        var n = 0;
        n = if (x8) 2 * n + 1 else 2 * n;
        n = if (x7) 2 * n + 1 else 2 * n;
        n = if (x6) 2 * n + 1 else 2 * n;
        n = if (x5) 2 * n + 1 else 2 * n;
        n = if (x4) 2 * n + 1 else 2 * n;
        n = if (x3) 2 * n + 1 else 2 * n;
        n = if (x2) 2 * n + 1 else 2 * n;
        n = if (x1) 2 * n + 1 else 2 * n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[Str.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._
\<close>


(* Directive pour l'exportation de l'analyseur *)

export_code san5 in Scala (case_insensitive)

(* file "~/workspace/TP67/src/tp67/san.scala"   (* √† adapter en fonction du chemin de votre projet TP67 *)
*)

end